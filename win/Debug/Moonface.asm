; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
CONST	SEGMENT
$SG117886 DB	'%s v%d.%d', 0dH, '%s', 00H
$SG117968 DB	00H
$SG117984 DB	00H
$SG118000 DB	00H
$SG117887 DB	'http://syuilo.com', 00H
$SG118016 DB	00H
	ORG $+1
$SG117888 DB	'open', 00H
	ORG $+3
$SG117969 DB	'Top', 00H
$SG117923 DB	'Block size', 00H
	ORG $+5
$SG117938 DB	'Vibration', 00H
	ORG $+6
$SG117953 DB	'Direction', 00H
	ORG $+2
$SG117985 DB	'Bottom', 00H
	ORG $+1
$SG118001 DB	'Left', 00H
	ORG $+3
$SG118017 DB	'Right', 00H
	ORG $+2
$SG118046 DB	'PRNG', 00H
	ORG $+7
$SG118047 DB	090H, 0fcH, 08cH, '`', 08dH, 087H, 093H, 0afH, 096H, '@|', 083H
	DB	081H, 083H, 08bH, 083H, 'Z', 083H, 093H, 083H, 'k', 081H, 'E', 083H
	DB	'c', 083H, 'C', 083H, 'X', 083H, '^ (MT19937)', 00H
	ORG $+6
$SG118062 DB	'Random seed', 00H
$SG118077 DB	'Border', 00H
	ORG $+5
$SG118078 DB	'None|Expand|Mirror|Tile', 00H
$SG118093 DB	'Merge', 00H
	ORG $+2
$SG118094 DB	08cH, 0b3H, 089H, 0e6H, 091H, 09cH, 082H, 0c6H, 08dH, 087H
	DB	090H, 0acH, 082H, 0b5H, 082H, 0dcH, 082H, 0b7H, 081H, 'B', 00H
CONST	ENDS
_DATA	SEGMENT
mti	DD	0271H
_DATA	ENDS
PUBLIC	?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z	; AEGP_SuiteHandler::LoadSuite
PUBLIC	?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ ; AEGP_SuiteHandler::ANSICallbacksSuite1
PUBLIC	EntryPointFunc
PUBLIC	?init_genrand@@YAXK@Z				; init_genrand
PUBLIC	?init_by_array@@YAXQEAKH@Z			; init_by_array
PUBLIC	?genrand_int32@@YAKXZ				; genrand_int32
PUBLIC	?genrand_int31@@YAJXZ				; genrand_int31
PUBLIC	?genrand_real1@@YANXZ				; genrand_real1
PUBLIC	?genrand_real2@@YANXZ				; genrand_real2
PUBLIC	?genrand_real3@@YANXZ				; genrand_real3
PUBLIC	?genrand_res53@@YANXZ				; genrand_res53
PUBLIC	??_C@_0O@JPGHEGPP@PF?5ANSI?5Suite?$AA@		; `string'
PUBLIC	??_R0J@8					; long `RTTI Type Descriptor'
PUBLIC	__real@3ca0000000000000
PUBLIC	__real@3df0000000000000
PUBLIC	__real@3df0000000100000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4190000000000000
EXTRN	__imp_ShellExecuteA:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_srand:PROC
EXTRN	GetStringPtr:PROC
EXTRN	?MissingSuiteError@AEGP_SuiteHandler@@AEBAXXZ:PROC ; AEGP_SuiteHandler::MissingSuiteError
EXTRN	??0AEGP_SuiteHandler@@QEAA@PEBUSPBasicSuite@@@Z:PROC ; AEGP_SuiteHandler::AEGP_SuiteHandler
EXTRN	??1AEGP_SuiteHandler@@QEAA@XZ:PROC		; AEGP_SuiteHandler::~AEGP_SuiteHandler
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
mt	DD	0270H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$EntryPointFunc DD imagerel $LN15
	DD	imagerel $LN15+262
	DD	imagerel $unwind$EntryPointFunc
pdata	ENDS
pdata	SEGMENT
$pdata$EntryPointFunc$catch$0 DD imagerel EntryPointFunc$catch$0
	DD	imagerel EntryPointFunc$catch$0+36
	DD	imagerel $unwind$EntryPointFunc$catch$0
pdata	ENDS
pdata	SEGMENT
$pdata$?init_by_array@@YAXQEAKH@Z DD imagerel $LN14
	DD	imagerel $LN14+592
	DD	imagerel $unwind$?init_by_array@@YAXQEAKH@Z
$pdata$?genrand_int32@@YAKXZ DD imagerel $LN11
	DD	imagerel $LN11+595
	DD	imagerel $unwind$?genrand_int32@@YAKXZ
$pdata$?genrand_int31@@YAJXZ DD imagerel $LN3
	DD	imagerel $LN3+16
	DD	imagerel $unwind$?genrand_int31@@YAJXZ
$pdata$?genrand_real1@@YANXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?genrand_real1@@YANXZ
$pdata$?genrand_real2@@YANXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?genrand_real2@@YANXZ
$pdata$?genrand_real3@@YANXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?genrand_real3@@YANXZ
$pdata$?genrand_res53@@YANXZ DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?genrand_res53@@YANXZ
$pdata$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD imagerel ?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	imagerel ?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+239
	DD	imagerel $unwind$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA DD imagerel ?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA
	DD	imagerel ?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD imagerel ?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	imagerel ?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+3448
	DD	imagerel $unwind$?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
$pdata$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD imagerel ?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	imagerel ?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+2580
	DD	imagerel $unwind$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA DD imagerel ?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA
	DD	imagerel ?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA
pdata	ENDS
;	COMDAT __real@4190000000000000
CONST	SEGMENT
__real@4190000000000000 DQ 04190000000000000r	; 6.71089e+007
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3df0000000100000
CONST	SEGMENT
__real@3df0000000100000 DQ 03df0000000100000r	; 2.32831e-010
CONST	ENDS
;	COMDAT __real@3df0000000000000
CONST	SEGMENT
__real@3df0000000000000 DQ 03df0000000000000r	; 2.32831e-010
CONST	ENDS
;	COMDAT __real@3ca0000000000000
CONST	SEGMENT
__real@3ca0000000000000 DQ 03ca0000000000000r	; 1.11022e-016
CONST	ENDS
;	COMDAT ??_R0J@8
data$r	SEGMENT
??_R0J@8 DQ	FLAT:??_7type_info@@6B@			; long `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.J', 00H
data$r	ENDS
;	COMDAT ?mag01@?1??genrand_int32@@YAKXZ@4PAKA
_DATA	SEGMENT
?mag01@?1??genrand_int32@@YAKXZ@4PAKA DD 00H		; `genrand_int32'::`2'::mag01
	DD	09908b0dfH
_DATA	ENDS
;	COMDAT ??_C@_0O@JPGHEGPP@PF?5ANSI?5Suite?$AA@
CONST	SEGMENT
??_C@_0O@JPGHEGPP@PF?5ANSI?5Suite?$AA@ DB 'PF ANSI Suite', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$cppxdata$EntryPointFunc DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$EntryPointFunc
	DD	01H
	DD	imagerel $tryMap$EntryPointFunc
	DD	06H
	DD	imagerel $ip2state$EntryPointFunc
	DD	038H
	DD	00H
	DD	01H
$cppxdata$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	050H
	DD	00H
	DD	01H
$cppxdata$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	0f0H
	DD	00H
	DD	01H
CONST	ENDS
xdata	SEGMENT
$unwind$EntryPointFunc DD 012019H
	DD	0a217H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$EntryPointFunc
$stateUnwindMap$EntryPointFunc DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$tryMap$EntryPointFunc DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$EntryPointFunc
$handlerMap$0$EntryPointFunc DD 08H
	DD	FLAT:??_R0J@8
	DD	040H
	DD	imagerel EntryPointFunc$catch$0
	DD	038H
$ip2state$EntryPointFunc DD imagerel EntryPointFunc
	DD	0ffffffffH
	DD	imagerel EntryPointFunc+40
	DD	00H
	DD	imagerel EntryPointFunc+251
	DD	0ffffffffH
	DD	imagerel EntryPointFunc$catch$0
	DD	00H
	DD	imagerel EntryPointFunc$catch$0+13
	DD	01H
	DD	imagerel EntryPointFunc$catch$0+22
	DD	00H
$unwind$EntryPointFunc$catch$0 DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$EntryPointFunc
$unwind$?init_by_array@@YAXQEAKH@Z DD 010d01H
	DD	0620dH
$unwind$?genrand_int32@@YAKXZ DD 010401H
	DD	06204H
$unwind$?genrand_int31@@YAJXZ DD 010401H
	DD	04204H
$unwind$?genrand_real1@@YANXZ DD 010401H
	DD	04204H
$unwind$?genrand_real2@@YANXZ DD 010401H
	DD	04204H
$unwind$?genrand_real3@@YANXZ DD 010401H
	DD	04204H
$unwind$?genrand_res53@@YANXZ DD 010401H
	DD	06204H
$unwind$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 022411H
	DD	079011bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
$stateUnwindMap$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA
$ip2state$?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD imagerel ?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	0ffffffffH
	DD	imagerel ?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+62
	DD	00H
	DD	imagerel ?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+217
	DD	0ffffffffH
$unwind$?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 022d19H
	DD	043011bH
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 023919H
	DD	093011bH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	0482H
$stateUnwindMap$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA
$ip2state$?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z DD imagerel ?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z
	DD	0ffffffffH
	DD	imagerel ?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+97
	DD	00H
	DD	imagerel ?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z+2536
	DD	0ffffffffH
$unwind$?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z DD 011301H
	DD	06213H
xdata	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
py$1 = 48
px$2 = 52
height$ = 56
width$ = 60
tv76 = 64
tv151 = 65
tv130 = 66
is16Bit$ = 67
tv144 = 68
tv137 = 69
tv173 = 70
xr$3 = 72
x$4 = 76
yr$5 = 80
y$6 = 84
inWidth$ = 88
pixel$7 = 92
setx$8 = 96
ix$9 = 100
tv330 = 104
tx$10 = 108
sety$11 = 112
ty$12 = 116
iy$13 = 120
_t$14 = 124
input$ = 128
outWidth$ = 136
tv249 = 140
tv240 = 144
inData$15 = 152
$T16 = 160
ytile$ = 164
_p$17 = 168
tv79 = 176
$T18 = 180
xtile$ = 184
err$ = 188
$T19 = 192
$T20 = 196
$T21 = 200
outData$22 = 208
outData$23 = 216
inData$24 = 224
pixel$25 = 232
$T26 = 240
suites$ = 256
niP$ = 1120
__$ArrayPad$ = 1152
in_data$ = 1184
out_data$ = 1192
params$ = 1200
output$ = 1208
?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z PROC ; Render

; 156  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1176				; 00000498H
	mov	QWORD PTR $T26[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 157  :     PF_Err				err = PF_Err_NONE;

	mov	DWORD PTR err$[rsp], 0

; 158  :     AEGP_SuiteHandler	suites(in_data->pica_basicP);

	mov	rax, QWORD PTR in_data$[rsp]
	mov	rdx, QWORD PTR [rax+384]
	lea	rcx, QWORD PTR suites$[rsp]
	call	??0AEGP_SuiteHandler@@QEAA@PEBUSPBasicSuite@@@Z ; AEGP_SuiteHandler::AEGP_SuiteHandler
	npad	1

; 159  : 
; 160  :     PF_EffectWorld *input = &params[MOONFACE_INPUT]->u.ld;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	add	rax, 56					; 00000038H
	mov	QWORD PTR input$[rsp], rax

; 161  :     PF_Boolean is16Bit PF_WORLD_IS_DEEP(output);

	mov	rax, QWORD PTR output$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN62@Render
	mov	BYTE PTR tv76[rsp], 1
	jmp	SHORT $LN63@Render
$LN62@Render:
	mov	BYTE PTR tv76[rsp], 0
$LN63@Render:
	movzx	eax, BYTE PTR tv76[rsp]
	mov	BYTE PTR is16Bit$[rsp], al
$LN59@Render:

; 162  : 
; 163  :     ParamInfo niP;
; 164  :     AEFX_CLR_STRUCT(niP);

	mov	DWORD PTR _t$14[rsp], 28
	lea	rax, QWORD PTR niP$[rsp]
	mov	QWORD PTR _p$17[rsp], rax
$LN56@Render:
	mov	eax, DWORD PTR _t$14[rsp]
	mov	DWORD PTR tv79[rsp], eax
	mov	eax, DWORD PTR _t$14[rsp]
	dec	eax
	mov	DWORD PTR _t$14[rsp], eax
	cmp	DWORD PTR tv79[rsp], 0
	je	SHORT $LN55@Render
	mov	rax, QWORD PTR _p$17[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$17[rsp]
	inc	rax
	mov	QWORD PTR _p$17[rsp], rax
	jmp	SHORT $LN56@Render
$LN55@Render:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN59@Render

; 165  : 
; 166  :     niP.size = params[MOONFACE_SIZE]->u.sd.value;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR niP$[rsp], eax

; 167  :     niP.vibration = params[MOONFACE_VIBRATION]->u.sd.value;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR niP$[rsp+4], eax

; 168  :     niP.directionTop = params[MOONFACE_DIRECTION_TOP]->u.bd.value;

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN64@Render
	mov	BYTE PTR tv130[rsp], 1
	jmp	SHORT $LN65@Render
$LN64@Render:
	mov	BYTE PTR tv130[rsp], 0
$LN65@Render:
	movzx	eax, BYTE PTR tv130[rsp]
	mov	BYTE PTR niP$[rsp+8], al

; 169  :     niP.directionBottom = params[MOONFACE_DIRECTION_BOTTOM]->u.bd.value;

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN66@Render
	mov	BYTE PTR tv137[rsp], 1
	jmp	SHORT $LN67@Render
$LN66@Render:
	mov	BYTE PTR tv137[rsp], 0
$LN67@Render:
	movzx	eax, BYTE PTR tv137[rsp]
	mov	BYTE PTR niP$[rsp+9], al

; 170  :     niP.directionLeft = params[MOONFACE_DIRECTION_LEFT]->u.bd.value;

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN68@Render
	mov	BYTE PTR tv144[rsp], 1
	jmp	SHORT $LN69@Render
$LN68@Render:
	mov	BYTE PTR tv144[rsp], 0
$LN69@Render:
	movzx	eax, BYTE PTR tv144[rsp]
	mov	BYTE PTR niP$[rsp+10], al

; 171  :     niP.directionRight = params[MOONFACE_DIRECTION_RIGHT]->u.bd.value;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN70@Render
	mov	BYTE PTR tv151[rsp], 1
	jmp	SHORT $LN71@Render
$LN70@Render:
	mov	BYTE PTR tv151[rsp], 0
$LN71@Render:
	movzx	eax, BYTE PTR tv151[rsp]
	mov	BYTE PTR niP$[rsp+11], al

; 172  :     niP.prng = params[MOONFACE_PRNG]->u.pd.value;

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR niP$[rsp+12], eax

; 173  :     niP.seed = params[MOONFACE_SEED]->u.sd.value;

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR niP$[rsp+16], eax

; 174  :     niP.border = params[MOONFACE_BORDER]->u.pd.value;

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR niP$[rsp+20], eax

; 175  :     niP.merge = params[MOONFACE_MERGE]->u.bd.value;

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR params$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	cmp	DWORD PTR [rax+56], 0
	je	SHORT $LN72@Render
	mov	BYTE PTR tv173[rsp], 1
	jmp	SHORT $LN73@Render
$LN72@Render:
	mov	BYTE PTR tv173[rsp], 0
$LN73@Render:
	movzx	eax, BYTE PTR tv173[rsp]
	mov	BYTE PTR niP$[rsp+24], al

; 176  : 
; 177  :     A_long width = input->width;

	mov	rax, QWORD PTR input$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR width$[rsp], eax

; 178  :     A_long height = input->height;

	mov	rax, QWORD PTR input$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR height$[rsp], eax

; 179  : 
; 180  :     A_long outWidth, inWidth;
; 181  :     if (is16Bit == TRUE) {

	movsx	eax, BYTE PTR is16Bit$[rsp]
	cmp	eax, 1
	jne	SHORT $LN54@Render

; 182  :         outWidth = output->rowbytes / sizeof(PF_Pixel16);

	mov	rax, QWORD PTR output$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	mov	DWORD PTR outWidth$[rsp], eax

; 183  :         inWidth = input->rowbytes / sizeof(PF_Pixel16);

	mov	rax, QWORD PTR input$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	mov	DWORD PTR inWidth$[rsp], eax

; 184  :     } else {

	jmp	SHORT $LN53@Render
$LN54@Render:

; 185  :         outWidth = output->rowbytes / sizeof(PF_Pixel);

	mov	rax, QWORD PTR output$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	DWORD PTR outWidth$[rsp], eax

; 186  :         inWidth = input->rowbytes / sizeof(PF_Pixel);

	mov	rax, QWORD PTR input$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	DWORD PTR inWidth$[rsp], eax
$LN53@Render:

; 187  :     }
; 188  : 
; 189  :     if (niP.merge)

	movzx	eax, BYTE PTR niP$[rsp+24]
	test	eax, eax
	je	SHORT $LN52@Render

; 190  :         PF_COPY(input, output, NULL, NULL);

	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR output$[rsp]
	mov	rdx, QWORD PTR input$[rsp]
	mov	rcx, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	call	QWORD PTR [rax+64]
$LN52@Render:

; 191  : 
; 192  :     // タイル数を算出
; 193  :     int xtile = (int)(width / niP.size) + 1;

	mov	eax, DWORD PTR width$[rsp]
	cdq
	idiv	DWORD PTR niP$[rsp]
	inc	eax
	mov	DWORD PTR xtile$[rsp], eax

; 194  :     int ytile = (int)(height / niP.size) + 1;

	mov	eax, DWORD PTR height$[rsp]
	cdq
	idiv	DWORD PTR niP$[rsp]
	inc	eax
	mov	DWORD PTR ytile$[rsp], eax

; 195  : 
; 196  :     switch (niP.prng)

	mov	eax, DWORD PTR niP$[rsp+12]
	mov	DWORD PTR tv240[rsp], eax
	cmp	DWORD PTR tv240[rsp], 1
	je	SHORT $LN49@Render
	cmp	DWORD PTR tv240[rsp], 2
	je	SHORT $LN48@Render
	jmp	SHORT $LN50@Render
$LN49@Render:

; 197  :     {
; 198  :         case 1:
; 199  :             srand(niP.seed);

	mov	ecx, DWORD PTR niP$[rsp+16]
	call	QWORD PTR __imp_srand

; 200  :             break;

	jmp	SHORT $LN50@Render
$LN48@Render:

; 201  :         case 2:
; 202  :             init_genrand(niP.seed);

	mov	ecx, DWORD PTR niP$[rsp+16]
	call	?init_genrand@@YAXK@Z			; init_genrand
$LN50@Render:

; 203  :             break;
; 204  :     }
; 205  : 
; 206  :     for (int ix = -1; ix < xtile; ix++) {

	mov	DWORD PTR ix$9[rsp], -1
	jmp	SHORT $LN47@Render
$LN46@Render:
	mov	eax, DWORD PTR ix$9[rsp]
	inc	eax
	mov	DWORD PTR ix$9[rsp], eax
$LN47@Render:
	mov	eax, DWORD PTR xtile$[rsp]
	cmp	DWORD PTR ix$9[rsp], eax
	jge	$LN45@Render

; 207  :         for (int iy = -1; iy < ytile; iy++)

	mov	DWORD PTR iy$13[rsp], -1
	jmp	SHORT $LN44@Render
$LN43@Render:
	mov	eax, DWORD PTR iy$13[rsp]
	inc	eax
	mov	DWORD PTR iy$13[rsp], eax
$LN44@Render:
	mov	eax, DWORD PTR ytile$[rsp]
	cmp	DWORD PTR iy$13[rsp], eax
	jge	$LN42@Render

; 208  :         {
; 209  :             // 揺れを算出
; 210  :             int xr = 0;

	mov	DWORD PTR xr$3[rsp], 0

; 211  :             int yr = 0;

	mov	DWORD PTR yr$5[rsp], 0

; 212  : 
; 213  :             switch (niP.prng)

	mov	eax, DWORD PTR niP$[rsp+12]
	mov	DWORD PTR tv249[rsp], eax
	cmp	DWORD PTR tv249[rsp], 1
	je	SHORT $LN39@Render
	cmp	DWORD PTR tv249[rsp], 2
	je	$LN34@Render
	jmp	$LN40@Render
$LN39@Render:

; 214  :             {
; 215  :                 case 1: // 線形合同法
; 216  :                     if (niP.directionTop)

	movzx	eax, BYTE PTR niP$[rsp+8]
	test	eax, eax
	je	SHORT $LN38@Render

; 217  :                         yr += -(rand() % niP.vibration);

	call	QWORD PTR __imp_rand
	cdq
	idiv	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	neg	eax
	mov	ecx, DWORD PTR yr$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR yr$5[rsp], eax
$LN38@Render:

; 218  :                     if (niP.directionBottom)

	movzx	eax, BYTE PTR niP$[rsp+9]
	test	eax, eax
	je	SHORT $LN37@Render

; 219  :                         yr += (rand() % niP.vibration);

	call	QWORD PTR __imp_rand
	cdq
	idiv	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	mov	ecx, DWORD PTR yr$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR yr$5[rsp], eax
$LN37@Render:

; 220  :                     if (niP.directionLeft)

	movzx	eax, BYTE PTR niP$[rsp+10]
	test	eax, eax
	je	SHORT $LN36@Render

; 221  :                         xr += -(rand() % niP.vibration);

	call	QWORD PTR __imp_rand
	cdq
	idiv	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	neg	eax
	mov	ecx, DWORD PTR xr$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xr$3[rsp], eax
$LN36@Render:

; 222  :                     if (niP.directionRight)

	movzx	eax, BYTE PTR niP$[rsp+11]
	test	eax, eax
	je	SHORT $LN35@Render

; 223  :                         xr += (rand() % niP.vibration);

	call	QWORD PTR __imp_rand
	cdq
	idiv	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	mov	ecx, DWORD PTR xr$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xr$3[rsp], eax
$LN35@Render:

; 224  :                     break;

	jmp	$LN40@Render
$LN34@Render:

; 225  :                 case 2: // MT
; 226  :                     if (niP.directionTop)

	movzx	eax, BYTE PTR niP$[rsp+8]
	test	eax, eax
	je	SHORT $LN33@Render

; 227  :                         yr += -(genrand_int32() % niP.vibration);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	xor	edx, edx
	div	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	neg	eax
	mov	ecx, DWORD PTR yr$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR yr$5[rsp], eax
$LN33@Render:

; 228  :                     if (niP.directionBottom)

	movzx	eax, BYTE PTR niP$[rsp+9]
	test	eax, eax
	je	SHORT $LN32@Render

; 229  :                         yr += (genrand_int32() % niP.vibration);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	xor	edx, edx
	div	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	mov	ecx, DWORD PTR yr$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR yr$5[rsp], eax
$LN32@Render:

; 230  :                     if (niP.directionLeft)

	movzx	eax, BYTE PTR niP$[rsp+10]
	test	eax, eax
	je	SHORT $LN31@Render

; 231  :                         xr += -(genrand_int32() % niP.vibration);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	xor	edx, edx
	div	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	neg	eax
	mov	ecx, DWORD PTR xr$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xr$3[rsp], eax
$LN31@Render:

; 232  :                     if (niP.directionRight)

	movzx	eax, BYTE PTR niP$[rsp+11]
	test	eax, eax
	je	SHORT $LN40@Render

; 233  :                         xr += (genrand_int32() % niP.vibration);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	xor	edx, edx
	div	DWORD PTR niP$[rsp+4]
	mov	eax, edx
	mov	ecx, DWORD PTR xr$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR xr$3[rsp], eax
$LN40@Render:

; 234  :                     break;
; 235  :             }
; 236  : 
; 237  :             // 1タイルの描画
; 238  :             for (int tx = 0; tx < niP.size; tx++) {

	mov	DWORD PTR tx$10[rsp], 0
	jmp	SHORT $LN29@Render
$LN28@Render:
	mov	eax, DWORD PTR tx$10[rsp]
	inc	eax
	mov	DWORD PTR tx$10[rsp], eax
$LN29@Render:
	mov	eax, DWORD PTR niP$[rsp]
	cmp	DWORD PTR tx$10[rsp], eax
	jge	$LN27@Render

; 239  :                 for (int ty = 0; ty < niP.size; ty++)

	mov	DWORD PTR ty$12[rsp], 0
	jmp	SHORT $LN26@Render
$LN25@Render:
	mov	eax, DWORD PTR ty$12[rsp]
	inc	eax
	mov	DWORD PTR ty$12[rsp], eax
$LN26@Render:
	mov	eax, DWORD PTR niP$[rsp]
	cmp	DWORD PTR ty$12[rsp], eax
	jge	$LN24@Render

; 240  :                 {
; 241  :                     int px = (ix * niP.size) + tx;

	mov	eax, DWORD PTR ix$9[rsp]
	imul	eax, DWORD PTR niP$[rsp]
	add	eax, DWORD PTR tx$10[rsp]
	mov	DWORD PTR px$2[rsp], eax

; 242  :                     int py = (iy * niP.size) + ty;

	mov	eax, DWORD PTR iy$13[rsp]
	imul	eax, DWORD PTR niP$[rsp]
	add	eax, DWORD PTR ty$12[rsp]
	mov	DWORD PTR py$1[rsp], eax

; 243  : 
; 244  :                     int setx = (px + xr);

	mov	eax, DWORD PTR xr$3[rsp]
	mov	ecx, DWORD PTR px$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR setx$8[rsp], eax

; 245  :                     int sety = (py + yr);

	mov	eax, DWORD PTR yr$5[rsp]
	mov	ecx, DWORD PTR py$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR sety$11[rsp], eax

; 246  : 
; 247  :                     // 1タイルの1ピクセルの描画
; 248  :                     if ((setx >= 0) && (setx < width) && (sety >= 0) && (sety < height))

	cmp	DWORD PTR setx$8[rsp], 0
	jl	$LN23@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR setx$8[rsp], eax
	jge	$LN23@Render
	cmp	DWORD PTR sety$11[rsp], 0
	jl	$LN23@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR sety$11[rsp], eax
	jge	$LN23@Render

; 249  :                     {
; 250  :                         // 16bit
; 251  :                         if (is16Bit == TRUE) {

	movsx	eax, BYTE PTR is16Bit$[rsp]
	cmp	eax, 1
	jne	SHORT $LN22@Render

; 252  :                             PF_Pixel16 pixel;
; 253  : 
; 254  :                             PF_Pixel16 *outData = (PF_Pixel16 *)output->data;

	mov	rax, QWORD PTR output$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR outData$22[rsp], rax

; 255  :                             PF_Pixel16 *inData = (PF_Pixel16 *)input->data;

	mov	rax, QWORD PTR input$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR inData$24[rsp], rax

; 256  : 
; 257  :                             //switch (niP.border)
; 258  :                             //{
; 259  :                             //    case 1: // None
; 260  :                             //        if ((px >= 0) && (px < width) && (py >= 0) && (py < height)) // 通常
; 261  :                             //            pixel = inData[px + py * inWidth];
; 262  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py < height)) // → 右はみ出し
; 263  :                             //            pixel.alpha = 0;
; 264  :                             //        else if ((px >= 0) && (px < width) && (py >= 0) && (py >= height)) // ↓ 下はみ出し
; 265  :                             //            pixel.alpha = 0;
; 266  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py >= height)) // ↘ 右下はみ出し
; 267  :                             //            pixel.alpha = 0;
; 268  :                             //        else if ((px < 0) && (px < width) && (py >= 0) && (py < height)) // ← 左はみ出し
; 269  :                             //            pixel.alpha = 0;
; 270  :                             //        else if ((px >= 0) && (px < width) && (py < 0) && (py < height)) // ↑ 上はみ出し
; 271  :                             //            pixel.alpha = 0;
; 272  :                             //        else if ((px < 0) && (px < width) && (py < 0) && (py < height)) // ↖ 左上はみ出し
; 273  :                             //            pixel.alpha = 0;
; 274  :                             //        break;
; 275  :                             //    case 2: // Expand
; 276  :                             //        if ((px >= 0) && (px < width) && (py >= 0) && (py < height)) // 通常
; 277  :                             //            pixel = inData[px + py * inWidth];
; 278  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py < height)) // → 右はみ出し
; 279  :                             //            pixel = inData[(width - 1) + py * inWidth];
; 280  :                             //        else if ((px >= 0) && (px < width) && (py >= 0) && (py >= height)) // ↓ 下はみ出し
; 281  :                             //            pixel = inData[px + (height - 1) * inWidth];
; 282  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py >= height)) // ↘ 右下はみ出し
; 283  :                             //            pixel = inData[(width - 1) + (height - 1) * inWidth];
; 284  :                             //        else if ((px < 0) && (px < width) && (py >= 0) && (py < height)) // ← 左はみ出し
; 285  :                             //            pixel = inData[0 + py * inWidth];
; 286  :                             //        else if ((px >= 0) && (px < width) && (py < 0) && (py < height)) // ↑ 上はみ出し
; 287  :                             //            pixel = inData[px + 0 * inWidth];
; 288  :                             //        else if ((px < 0) && (px < width) && (py < 0) && (py < height)) // ↖ 左上はみ出し
; 289  :                             //            pixel = inData[0 + 0 * inWidth];
; 290  :                             //        break;
; 291  :                             //    case 3: // Mirror
; 292  :                             //        if ((px >= 0) && (px < width) && (py >= 0) && (py < height)) // 通常
; 293  :                             //            pixel = inData[px + py * inWidth];
; 294  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py < height)) // → 右はみ出し
; 295  :                             //            pixel = inData[(width - (px - width) - 1) + py * inWidth];
; 296  :                             //        else if ((px >= 0) && (px < width) && (py >= 0) && (py >= height)) // ↓ 下はみ出し
; 297  :                             //            pixel = inData[px + (height - (py - height) - 1) * inWidth];
; 298  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py >= height)) // ↘ 右下はみ出し
; 299  :                             //            pixel = inData[(width - (px - width) - 1) + (height - (py - height) - 1) * inWidth];
; 300  :                             //        else if ((px < 0) && (px < width) && (py >= 0) && (py < height)) // ← 左はみ出し
; 301  :                             //            pixel = inData[x + py * inWidth];
; 302  :                             //        else if ((px >= 0) && (px < width) && (py < 0) && (py < height)) // ↑ 上はみ出し
; 303  :                             //            pixel = inData[px + y * inWidth];
; 304  :                             //        else if ((px < 0) && (px < width) && (py < 0) && (py < height)) // ↖ 左上はみ出し
; 305  :                             //            pixel = inData[x + y * inWidth];
; 306  :                             //        break;
; 307  :                             //    case 4: // Tile
; 308  :                             //        if ((px >= 0) && (px < width) && (py >= 0) && (py < height)) // 通常
; 309  :                             //            pixel = inData[px + py * inWidth];
; 310  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py < height)) // → 右はみ出し
; 311  :                             //            pixel = inData[(px - width) + py * inWidth];
; 312  :                             //        else if ((px >= 0) && (px < width) && (py >= 0) && (py >= height)) // ↓ 下はみ出し
; 313  :                             //            pixel = inData[px + (py - height) * inWidth];
; 314  :                             //        else if ((px >= 0) && (px >= width) && (py >= 0) && (py >= height)) // ↘ 右下はみ出し
; 315  :                             //            pixel = inData[(px - width) + (py - height)  * inWidth];
; 316  :                             //        else if ((px < 0) && (px < width) && (py >= 0) && (py < height)) // ← 左はみ出し
; 317  :                             //            pixel = inData[x + py * inWidth];
; 318  :                             //        else if ((px >= 0) && (px < width) && (py < 0) && (py < height)) // ↑ 上はみ出し
; 319  :                             //            pixel = inData[px + y * inWidth];
; 320  :                             //        else if ((px < 0) && (px < width) && (py < 0) && (py < height)) // ↖ 左上はみ出し
; 321  :                             //            pixel = inData[x + y * inWidth];
; 322  :                             //        break;
; 323  :                             //}
; 324  :                             outData[setx + sety * outWidth] = pixel;

	mov	eax, DWORD PTR sety$11[rsp]
	imul	eax, DWORD PTR outWidth$[rsp]
	mov	ecx, DWORD PTR setx$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR outData$22[rsp]
	mov	rdx, QWORD PTR pixel$25[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 325  :                         } else { // 8bit

	jmp	$LN23@Render
$LN22@Render:

; 326  :                             int x, y;
; 327  :                             x = px;

	mov	eax, DWORD PTR px$2[rsp]
	mov	DWORD PTR x$4[rsp], eax

; 328  :                             y = py;

	mov	eax, DWORD PTR py$1[rsp]
	mov	DWORD PTR y$6[rsp], eax

; 329  :                             PF_Pixel pixel;
; 330  : 
; 331  :                             PF_Pixel *outData = (PF_Pixel *)output->data;

	mov	rax, QWORD PTR output$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR outData$23[rsp], rax

; 332  :                             PF_Pixel *inData = (PF_Pixel *)input->data;

	mov	rax, QWORD PTR input$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR inData$15[rsp], rax

; 333  : 
; 334  :                             if ((px >= 0) && (px < width) && (py >= 0) && (py < height)) // 通常

	cmp	DWORD PTR px$2[rsp], 0
	jl	SHORT $LN20@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jge	SHORT $LN20@Render
	cmp	DWORD PTR py$1[rsp], 0
	jl	SHORT $LN20@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jge	SHORT $LN20@Render

; 335  :                                 pixel = pGet(inData, px, py, inWidth);

	mov	r9d, DWORD PTR inWidth$[rsp]
	mov	r8d, DWORD PTR py$1[rsp]
	mov	edx, DWORD PTR px$2[rsp]
	mov	rcx, QWORD PTR inData$15[rsp]
	call	?pGet@@YA?AUPF_Pixel@@PEAU1@JJJ@Z	; pGet
	mov	DWORD PTR $T19[rsp], eax
	mov	eax, DWORD PTR $T19[rsp]
	mov	DWORD PTR pixel$7[rsp], eax

; 336  :                             else

	jmp	$LN19@Render
$LN20@Render:

; 337  :                                 switch (niP.border)

	mov	eax, DWORD PTR niP$[rsp+20]
	mov	DWORD PTR tv330[rsp], eax
	cmp	DWORD PTR tv330[rsp], 1
	je	SHORT $LN16@Render
	cmp	DWORD PTR tv330[rsp], 2
	je	SHORT $LN15@Render
	cmp	DWORD PTR tv330[rsp], 3
	je	$LN10@Render
	cmp	DWORD PTR tv330[rsp], 4
	je	$LN5@Render
	jmp	$LN19@Render
$LN16@Render:

; 338  :                             {
; 339  :                                     case 1: // None
; 340  :                                         pixel.alpha = 0;

	mov	BYTE PTR pixel$7[rsp], 0

; 341  :                                         break;

	jmp	$LN19@Render
$LN15@Render:

; 342  :                                     case 2: // Expand
; 343  :                                         if ((px >= 0) && (px >= width)) // → 右はみ出し

	cmp	DWORD PTR px$2[rsp], 0
	jl	SHORT $LN14@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jl	SHORT $LN14@Render

; 344  :                                             x = width - 1;

	mov	eax, DWORD PTR width$[rsp]
	dec	eax
	mov	DWORD PTR x$4[rsp], eax
$LN14@Render:

; 345  :                                         if ((py >= 0) && (py >= height)) // ↓ 下はみ出し

	cmp	DWORD PTR py$1[rsp], 0
	jl	SHORT $LN13@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jl	SHORT $LN13@Render

; 346  :                                             y = height - 1;

	mov	eax, DWORD PTR height$[rsp]
	dec	eax
	mov	DWORD PTR y$6[rsp], eax
$LN13@Render:

; 347  :                                         if ((px < 0) && (px < width)) // ← 左はみ出し

	cmp	DWORD PTR px$2[rsp], 0
	jge	SHORT $LN12@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jge	SHORT $LN12@Render

; 348  :                                             x = 0;

	mov	DWORD PTR x$4[rsp], 0
$LN12@Render:

; 349  :                                         if ((py < 0) && (py < height)) // ↑ 上はみ出し

	cmp	DWORD PTR py$1[rsp], 0
	jge	SHORT $LN11@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jge	SHORT $LN11@Render

; 350  :                                             y = 0;

	mov	DWORD PTR y$6[rsp], 0
$LN11@Render:

; 351  :                                         pixel = pGet(inData, x, y, inWidth);

	mov	r9d, DWORD PTR inWidth$[rsp]
	mov	r8d, DWORD PTR y$6[rsp]
	mov	edx, DWORD PTR x$4[rsp]
	mov	rcx, QWORD PTR inData$15[rsp]
	call	?pGet@@YA?AUPF_Pixel@@PEAU1@JJJ@Z	; pGet
	mov	DWORD PTR $T16[rsp], eax
	mov	eax, DWORD PTR $T16[rsp]
	mov	DWORD PTR pixel$7[rsp], eax

; 352  :                                         break;

	jmp	$LN19@Render
$LN10@Render:

; 353  :                                     case 3: // Mirror
; 354  :                                         if ((px >= 0) && (px >= width)) // → 右はみ出し

	cmp	DWORD PTR px$2[rsp], 0
	jl	SHORT $LN9@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jl	SHORT $LN9@Render

; 355  :                                             x = width - (px - width) - 1;

	mov	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR px$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR width$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	mov	DWORD PTR x$4[rsp], eax
$LN9@Render:

; 356  :                                         if ((py >= 0) && (py >= height)) // ↓ 下はみ出し

	cmp	DWORD PTR py$1[rsp], 0
	jl	SHORT $LN8@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jl	SHORT $LN8@Render

; 357  :                                             y = height - (py - height) - 1;

	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR py$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR height$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	dec	eax
	mov	DWORD PTR y$6[rsp], eax
$LN8@Render:

; 358  :                                         if ((px < 0) && (px < width)) // ← 左はみ出し

	cmp	DWORD PTR px$2[rsp], 0
	jge	SHORT $LN7@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jge	SHORT $LN7@Render

; 359  :                                             x = 0;

	mov	DWORD PTR x$4[rsp], 0
$LN7@Render:

; 360  :                                         if ((py < 0) && (py < height)) // ↑ 上はみ出し

	cmp	DWORD PTR py$1[rsp], 0
	jge	SHORT $LN6@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jge	SHORT $LN6@Render

; 361  :                                             y = 0;

	mov	DWORD PTR y$6[rsp], 0
$LN6@Render:

; 362  :                                         pixel = pGet(inData, x, y, inWidth);

	mov	r9d, DWORD PTR inWidth$[rsp]
	mov	r8d, DWORD PTR y$6[rsp]
	mov	edx, DWORD PTR x$4[rsp]
	mov	rcx, QWORD PTR inData$15[rsp]
	call	?pGet@@YA?AUPF_Pixel@@PEAU1@JJJ@Z	; pGet
	mov	DWORD PTR $T21[rsp], eax
	mov	eax, DWORD PTR $T21[rsp]
	mov	DWORD PTR pixel$7[rsp], eax

; 363  :                                         break;

	jmp	$LN19@Render
$LN5@Render:

; 364  :                                     case 4: // Tile
; 365  :                                         if ((px >= 0) && (px >= width)) // → 右はみ出し

	cmp	DWORD PTR px$2[rsp], 0
	jl	SHORT $LN4@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jl	SHORT $LN4@Render

; 366  :                                             x = px - width;

	mov	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR px$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$4[rsp], eax
$LN4@Render:

; 367  :                                         if ((py >= 0) && (py >= height)) // ↓ 下はみ出し

	cmp	DWORD PTR py$1[rsp], 0
	jl	SHORT $LN3@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jl	SHORT $LN3@Render

; 368  :                                             y = py - height;

	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR py$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$6[rsp], eax
$LN3@Render:

; 369  :                                         if ((px < 0) && (px < width)) // ← 左はみ出し

	cmp	DWORD PTR px$2[rsp], 0
	jge	SHORT $LN2@Render
	mov	eax, DWORD PTR width$[rsp]
	cmp	DWORD PTR px$2[rsp], eax
	jge	SHORT $LN2@Render

; 370  :                                             x = 0;

	mov	DWORD PTR x$4[rsp], 0
$LN2@Render:

; 371  :                                         if ((py < 0) && (py < height)) // ↑ 上はみ出し

	cmp	DWORD PTR py$1[rsp], 0
	jge	SHORT $LN1@Render
	mov	eax, DWORD PTR height$[rsp]
	cmp	DWORD PTR py$1[rsp], eax
	jge	SHORT $LN1@Render

; 372  :                                             y = 0;

	mov	DWORD PTR y$6[rsp], 0
$LN1@Render:

; 373  :                                         pixel = pGet(inData, x, y, inWidth);

	mov	r9d, DWORD PTR inWidth$[rsp]
	mov	r8d, DWORD PTR y$6[rsp]
	mov	edx, DWORD PTR x$4[rsp]
	mov	rcx, QWORD PTR inData$15[rsp]
	call	?pGet@@YA?AUPF_Pixel@@PEAU1@JJJ@Z	; pGet
	mov	DWORD PTR $T20[rsp], eax
	mov	eax, DWORD PTR $T20[rsp]
	mov	DWORD PTR pixel$7[rsp], eax
$LN19@Render:

; 374  :                                         break;
; 375  :                             }
; 376  :                             pSet(outData, setx, sety, outWidth, pixel);

	mov	eax, DWORD PTR pixel$7[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR outWidth$[rsp]
	mov	r8d, DWORD PTR sety$11[rsp]
	mov	edx, DWORD PTR setx$8[rsp]
	mov	rcx, QWORD PTR outData$23[rsp]
	call	?pSet@@YAJPEAUPF_Pixel@@JJJU1@@Z	; pSet
$LN23@Render:

; 377  :                         }
; 378  :                     }
; 379  :                 }

	jmp	$LN25@Render
$LN24@Render:

; 380  :             }

	jmp	$LN28@Render
$LN27@Render:

; 381  :         }

	jmp	$LN43@Render
$LN42@Render:

; 382  :     }

	jmp	$LN46@Render
$LN45@Render:

; 383  : 
; 384  :     return err;

	mov	eax, DWORD PTR err$[rsp]
	mov	DWORD PTR $T18[rsp], eax
	lea	rcx, QWORD PTR suites$[rsp]
	call	??1AEGP_SuiteHandler@@QEAA@XZ		; AEGP_SuiteHandler::~AEGP_SuiteHandler
	mov	eax, DWORD PTR $T18[rsp]

; 385  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1176				; 00000498H
	ret	0
?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ENDP ; Render
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
py$1 = 48
px$2 = 52
height$ = 56
width$ = 60
tv76 = 64
tv151 = 65
tv130 = 66
is16Bit$ = 67
tv144 = 68
tv137 = 69
tv173 = 70
xr$3 = 72
x$4 = 76
yr$5 = 80
y$6 = 84
inWidth$ = 88
pixel$7 = 92
setx$8 = 96
ix$9 = 100
tv330 = 104
tx$10 = 108
sety$11 = 112
ty$12 = 116
iy$13 = 120
_t$14 = 124
input$ = 128
outWidth$ = 136
tv249 = 140
tv240 = 144
inData$15 = 152
$T16 = 160
ytile$ = 164
_p$17 = 168
tv79 = 176
$T18 = 180
xtile$ = 184
err$ = 188
$T19 = 192
$T20 = 196
$T21 = 200
outData$22 = 208
outData$23 = 216
inData$24 = 224
pixel$25 = 232
$T26 = 240
suites$ = 256
niP$ = 1120
__$ArrayPad$ = 1152
in_data$ = 1184
out_data$ = 1192
params$ = 1200
output$ = 1208
?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA PROC ; `Render'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR suites$[rbp]
	call	??1AEGP_SuiteHandler@@QEAA@XZ		; AEGP_SuiteHandler::~AEGP_SuiteHandler
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA ENDP ; `Render'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
data$ = 8
x$ = 16
y$ = 24
width$ = 32
?pGet@@YA?AUPF_Pixel@@PEAU1@JJJ@Z PROC			; pGet

; 151  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 152  :     return data[x + y * width];

	mov	eax, DWORD PTR y$[rsp]
	imul	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR data$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]

; 153  : }

	ret	0
?pGet@@YA?AUPF_Pixel@@PEAU1@JJJ@Z ENDP			; pGet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
data$ = 8
x$ = 16
y$ = 24
width$ = 32
pixel$ = 40
?pSet@@YAJPEAUPF_Pixel@@JJJU1@@Z PROC			; pSet

; 145  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 146  :     data[x + y * width] = pixel;

	mov	eax, DWORD PTR y$[rsp]
	imul	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR data$[rsp]
	mov	edx, DWORD PTR pixel$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 147  :     return PF_Err_NONE;

	xor	eax, eax

; 148  : }

	ret	0
?pSet@@YAJPEAUPF_Pixel@@JJJU1@@Z ENDP			; pSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
priv_err$1 = 32
_t$2 = 36
priv_err$3 = 40
priv_err$4 = 44
priv_err$5 = 48
_t$6 = 52
priv_err$7 = 56
priv_err$8 = 60
priv_err$9 = 64
_t$10 = 68
priv_err$11 = 72
priv_err$12 = 76
_t$13 = 80
_t$14 = 84
_t$15 = 88
priv_err$16 = 92
_t$17 = 96
_t$18 = 100
_t$19 = 104
priv_err$20 = 108
_t$21 = 112
_t$22 = 116
_t$23 = 120
priv_err$24 = 124
tv66 = 128
_p$25 = 136
tv89 = 144
_p$26 = 152
tv195 = 160
_p$27 = 168
tv233 = 176
_p$28 = 184
tv271 = 192
_p$29 = 200
tv304 = 208
_p$30 = 216
tv346 = 224
_p$31 = 232
tv144 = 240
_p$32 = 248
tv252 = 256
_p$33 = 264
tv327 = 272
_p$34 = 280
tv214 = 288
_p$35 = 296
err$ = 304
_p$36 = 312
tv285 = 320
def$ = 336
__$ArrayPad$ = 512
in_data$ = 544
out_data$ = 552
params$ = 560
output$ = 568
?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z PROC ; ParamsSetup

; 44   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 536				; 00000218H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 45   :     PF_Err		err = PF_Err_NONE;

	mov	DWORD PTR err$[rsp], 0
$LN108@ParamsSetu:

; 46   :     PF_ParamDef	def;
; 47   : 
; 48   :     // ------------------------
; 49   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$13[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$25[rsp], rax
$LN105@ParamsSetu:
	mov	eax, DWORD PTR _t$13[rsp]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR _t$13[rsp]
	dec	eax
	mov	DWORD PTR _t$13[rsp], eax
	cmp	DWORD PTR tv66[rsp], 0
	je	SHORT $LN104@ParamsSetu
	mov	rax, QWORD PTR _p$25[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$25[rsp]
	inc	rax
	mov	QWORD PTR _p$25[rsp], rax
	jmp	SHORT $LN105@ParamsSetu
$LN104@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN108@ParamsSetu
$LN103@ParamsSetu:

; 50   :     PF_ADD_SLIDER("Block size",
; 51   :         1,
; 52   :         2048,
; 53   :         1,
; 54   :         1024,
; 55   :         64,
; 56   :         1);

	mov	DWORD PTR priv_err$3[rsp], 0
	mov	DWORD PTR def$[rsp+12], 1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG117923
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR def$[rsp+rax+60], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR def$[rsp+rax+92], 0
	mov	DWORD PTR def$[rsp+124], 1
	mov	DWORD PTR def$[rsp+132], 1
	mov	DWORD PTR def$[rsp+128], 2048		; 00000800H
	mov	DWORD PTR def$[rsp+136], 1024		; 00000400H
	mov	DWORD PTR def$[rsp+140], 64		; 00000040H
	mov	eax, DWORD PTR def$[rsp+140]
	mov	DWORD PTR def$[rsp+56], eax
	mov	DWORD PTR def$[rsp], 1
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$3[rsp], eax
	cmp	DWORD PTR priv_err$3[rsp], 0
	je	SHORT $LN100@ParamsSetu
	mov	eax, DWORD PTR priv_err$3[rsp]
	jmp	$LN109@ParamsSetu
$LN100@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN103@ParamsSetu
$LN99@ParamsSetu:

; 57   : 
; 58   :     // ------------------------
; 59   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$19[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$26[rsp], rax
$LN96@ParamsSetu:
	mov	eax, DWORD PTR _t$19[rsp]
	mov	DWORD PTR tv89[rsp], eax
	mov	eax, DWORD PTR _t$19[rsp]
	dec	eax
	mov	DWORD PTR _t$19[rsp], eax
	cmp	DWORD PTR tv89[rsp], 0
	je	SHORT $LN95@ParamsSetu
	mov	rax, QWORD PTR _p$26[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$26[rsp]
	inc	rax
	mov	QWORD PTR _p$26[rsp], rax
	jmp	SHORT $LN96@ParamsSetu
$LN95@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN99@ParamsSetu
$LN94@ParamsSetu:

; 60   :     PF_ADD_SLIDER("Vibration",
; 61   :         1,
; 62   :         8192,
; 63   :         1,
; 64   :         1024,
; 65   :         64,
; 66   :         2);

	mov	DWORD PTR priv_err$5[rsp], 0
	mov	DWORD PTR def$[rsp+12], 1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG117938
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR def$[rsp+rax+60], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR def$[rsp+rax+92], 0
	mov	DWORD PTR def$[rsp+124], 1
	mov	DWORD PTR def$[rsp+132], 1
	mov	DWORD PTR def$[rsp+128], 8192		; 00002000H
	mov	DWORD PTR def$[rsp+136], 1024		; 00000400H
	mov	DWORD PTR def$[rsp+140], 64		; 00000040H
	mov	eax, DWORD PTR def$[rsp+140]
	mov	DWORD PTR def$[rsp+56], eax
	mov	DWORD PTR def$[rsp], 2
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$5[rsp], eax
	cmp	DWORD PTR priv_err$5[rsp], 0
	je	SHORT $LN91@ParamsSetu
	mov	eax, DWORD PTR priv_err$5[rsp]
	jmp	$LN109@ParamsSetu
$LN91@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN94@ParamsSetu
$LN90@ParamsSetu:

; 67   : 
; 68   :     // ------------------------
; 69   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$15[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$27[rsp], rax
$LN87@ParamsSetu:
	mov	eax, DWORD PTR _t$15[rsp]
	mov	DWORD PTR tv144[rsp], eax
	mov	eax, DWORD PTR _t$15[rsp]
	dec	eax
	mov	DWORD PTR _t$15[rsp], eax
	cmp	DWORD PTR tv144[rsp], 0
	je	SHORT $LN86@ParamsSetu
	mov	rax, QWORD PTR _p$27[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$27[rsp]
	inc	rax
	mov	QWORD PTR _p$27[rsp], rax
	jmp	SHORT $LN87@ParamsSetu
$LN86@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN90@ParamsSetu
$LN85@ParamsSetu:

; 70   :     PF_ADD_TOPIC("Direction",
; 71   :         3);

	mov	DWORD PTR priv_err$7[rsp], 0
	mov	DWORD PTR def$[rsp+12], 13
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG117953
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	mov	DWORD PTR def$[rsp], 3
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$7[rsp], eax
	cmp	DWORD PTR priv_err$7[rsp], 0
	je	SHORT $LN82@ParamsSetu
	mov	eax, DWORD PTR priv_err$7[rsp]
	jmp	$LN109@ParamsSetu
$LN82@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN85@ParamsSetu
$LN81@ParamsSetu:

; 72   : 
; 73   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$23[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$28[rsp], rax
$LN78@ParamsSetu:
	mov	eax, DWORD PTR _t$23[rsp]
	mov	DWORD PTR tv195[rsp], eax
	mov	eax, DWORD PTR _t$23[rsp]
	dec	eax
	mov	DWORD PTR _t$23[rsp], eax
	cmp	DWORD PTR tv195[rsp], 0
	je	SHORT $LN77@ParamsSetu
	mov	rax, QWORD PTR _p$28[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$28[rsp]
	inc	rax
	mov	QWORD PTR _p$28[rsp], rax
	jmp	SHORT $LN78@ParamsSetu
$LN77@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN81@ParamsSetu
$LN76@ParamsSetu:

; 74   :     PF_ADD_CHECKBOX("",
; 75   :         "Top",
; 76   :         TRUE,
; 77   :         0,
; 78   :         4);

	mov	DWORD PTR priv_err$9[rsp], 0
	mov	DWORD PTR def$[rsp+12], 4
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG117968
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	lea	rax, OFFSET FLAT:$SG117969
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp+56], 1
	mov	BYTE PTR def$[rsp+60], 1
	mov	eax, DWORD PTR def$[rsp+48]
	mov	DWORD PTR def$[rsp+48], eax
	mov	DWORD PTR def$[rsp], 4
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$9[rsp], eax
	cmp	DWORD PTR priv_err$9[rsp], 0
	je	SHORT $LN73@ParamsSetu
	mov	eax, DWORD PTR priv_err$9[rsp]
	jmp	$LN109@ParamsSetu
$LN73@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN76@ParamsSetu
$LN72@ParamsSetu:

; 79   : 
; 80   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$17[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$29[rsp], rax
$LN69@ParamsSetu:
	mov	eax, DWORD PTR _t$17[rsp]
	mov	DWORD PTR tv214[rsp], eax
	mov	eax, DWORD PTR _t$17[rsp]
	dec	eax
	mov	DWORD PTR _t$17[rsp], eax
	cmp	DWORD PTR tv214[rsp], 0
	je	SHORT $LN68@ParamsSetu
	mov	rax, QWORD PTR _p$29[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$29[rsp]
	inc	rax
	mov	QWORD PTR _p$29[rsp], rax
	jmp	SHORT $LN69@ParamsSetu
$LN68@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN72@ParamsSetu
$LN67@ParamsSetu:

; 81   :     PF_ADD_CHECKBOX("",
; 82   :         "Bottom",
; 83   :         TRUE,
; 84   :         0,
; 85   :         5);

	mov	DWORD PTR priv_err$11[rsp], 0
	mov	DWORD PTR def$[rsp+12], 4
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG117984
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	lea	rax, OFFSET FLAT:$SG117985
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp+56], 1
	mov	BYTE PTR def$[rsp+60], 1
	mov	eax, DWORD PTR def$[rsp+48]
	mov	DWORD PTR def$[rsp+48], eax
	mov	DWORD PTR def$[rsp], 5
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$11[rsp], eax
	cmp	DWORD PTR priv_err$11[rsp], 0
	je	SHORT $LN64@ParamsSetu
	mov	eax, DWORD PTR priv_err$11[rsp]
	jmp	$LN109@ParamsSetu
$LN64@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN67@ParamsSetu
$LN63@ParamsSetu:

; 86   : 
; 87   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$21[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$30[rsp], rax
$LN60@ParamsSetu:
	mov	eax, DWORD PTR _t$21[rsp]
	mov	DWORD PTR tv233[rsp], eax
	mov	eax, DWORD PTR _t$21[rsp]
	dec	eax
	mov	DWORD PTR _t$21[rsp], eax
	cmp	DWORD PTR tv233[rsp], 0
	je	SHORT $LN59@ParamsSetu
	mov	rax, QWORD PTR _p$30[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$30[rsp]
	inc	rax
	mov	QWORD PTR _p$30[rsp], rax
	jmp	SHORT $LN60@ParamsSetu
$LN59@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN63@ParamsSetu
$LN58@ParamsSetu:

; 88   :     PF_ADD_CHECKBOX("",
; 89   :         "Left",
; 90   :         TRUE,
; 91   :         0,
; 92   :         6);

	mov	DWORD PTR priv_err$1[rsp], 0
	mov	DWORD PTR def$[rsp+12], 4
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG118000
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	lea	rax, OFFSET FLAT:$SG118001
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp+56], 1
	mov	BYTE PTR def$[rsp+60], 1
	mov	eax, DWORD PTR def$[rsp+48]
	mov	DWORD PTR def$[rsp+48], eax
	mov	DWORD PTR def$[rsp], 6
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$1[rsp], eax
	cmp	DWORD PTR priv_err$1[rsp], 0
	je	SHORT $LN55@ParamsSetu
	mov	eax, DWORD PTR priv_err$1[rsp]
	jmp	$LN109@ParamsSetu
$LN55@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN58@ParamsSetu
$LN54@ParamsSetu:

; 93   : 
; 94   :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$2[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$31[rsp], rax
$LN51@ParamsSetu:
	mov	eax, DWORD PTR _t$2[rsp]
	mov	DWORD PTR tv252[rsp], eax
	mov	eax, DWORD PTR _t$2[rsp]
	dec	eax
	mov	DWORD PTR _t$2[rsp], eax
	cmp	DWORD PTR tv252[rsp], 0
	je	SHORT $LN50@ParamsSetu
	mov	rax, QWORD PTR _p$31[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$31[rsp]
	inc	rax
	mov	QWORD PTR _p$31[rsp], rax
	jmp	SHORT $LN51@ParamsSetu
$LN50@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN54@ParamsSetu
$LN49@ParamsSetu:

; 95   :     PF_ADD_CHECKBOX("",
; 96   :         "Right",
; 97   :         TRUE,
; 98   :         0,
; 99   :         7);

	mov	DWORD PTR priv_err$4[rsp], 0
	mov	DWORD PTR def$[rsp+12], 4
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG118016
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	lea	rax, OFFSET FLAT:$SG118017
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp+56], 1
	mov	BYTE PTR def$[rsp+60], 1
	mov	eax, DWORD PTR def$[rsp+48]
	mov	DWORD PTR def$[rsp+48], eax
	mov	DWORD PTR def$[rsp], 7
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$4[rsp], eax
	cmp	DWORD PTR priv_err$4[rsp], 0
	je	SHORT $LN46@ParamsSetu
	mov	eax, DWORD PTR priv_err$4[rsp]
	jmp	$LN109@ParamsSetu
$LN46@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN49@ParamsSetu
$LN45@ParamsSetu:

; 100  : 
; 101  :     // ------------------------
; 102  :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$6[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$32[rsp], rax
$LN42@ParamsSetu:
	mov	eax, DWORD PTR _t$6[rsp]
	mov	DWORD PTR tv271[rsp], eax
	mov	eax, DWORD PTR _t$6[rsp]
	dec	eax
	mov	DWORD PTR _t$6[rsp], eax
	cmp	DWORD PTR tv271[rsp], 0
	je	SHORT $LN41@ParamsSetu
	mov	rax, QWORD PTR _p$32[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$32[rsp]
	inc	rax
	mov	QWORD PTR _p$32[rsp], rax
	jmp	SHORT $LN42@ParamsSetu
$LN41@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN45@ParamsSetu
$LN40@ParamsSetu:

; 103  :     PF_END_TOPIC(8);

	mov	DWORD PTR priv_err$8[rsp], 0
	mov	DWORD PTR def$[rsp+12], 14
	mov	DWORD PTR def$[rsp], 8
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$8[rsp], eax
	cmp	DWORD PTR priv_err$8[rsp], 0
	je	SHORT $LN37@ParamsSetu
	mov	eax, DWORD PTR priv_err$8[rsp]
	jmp	$LN109@ParamsSetu
$LN37@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN40@ParamsSetu
$LN36@ParamsSetu:

; 104  : 
; 105  :     // ------------------------
; 106  :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$10[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$33[rsp], rax
$LN33@ParamsSetu:
	mov	eax, DWORD PTR _t$10[rsp]
	mov	DWORD PTR tv285[rsp], eax
	mov	eax, DWORD PTR _t$10[rsp]
	dec	eax
	mov	DWORD PTR _t$10[rsp], eax
	cmp	DWORD PTR tv285[rsp], 0
	je	SHORT $LN32@ParamsSetu
	mov	rax, QWORD PTR _p$33[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$33[rsp]
	inc	rax
	mov	QWORD PTR _p$33[rsp], rax
	jmp	SHORT $LN33@ParamsSetu
$LN32@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN36@ParamsSetu
$LN31@ParamsSetu:

; 107  :     PF_ADD_POPUP("PRNG",
; 108  :         2,
; 109  :         2,
; 110  :         "線形合同法|メルセンヌ・ツイスタ (MT19937)",
; 111  :         9);

	mov	DWORD PTR priv_err$12[rsp], 0
	mov	DWORD PTR def$[rsp+12], 7
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG118046
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	mov	eax, 2
	mov	WORD PTR def$[rsp+60], ax
	mov	eax, 2
	mov	WORD PTR def$[rsp+62], ax
	mov	DWORD PTR def$[rsp+56], 2
	lea	rax, OFFSET FLAT:$SG118047
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp], 9
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$12[rsp], eax
	cmp	DWORD PTR priv_err$12[rsp], 0
	je	SHORT $LN28@ParamsSetu
	mov	eax, DWORD PTR priv_err$12[rsp]
	jmp	$LN109@ParamsSetu
$LN28@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN31@ParamsSetu
$LN27@ParamsSetu:

; 112  : 
; 113  :     // ------------------------
; 114  :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$14[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$34[rsp], rax
$LN24@ParamsSetu:
	mov	eax, DWORD PTR _t$14[rsp]
	mov	DWORD PTR tv304[rsp], eax
	mov	eax, DWORD PTR _t$14[rsp]
	dec	eax
	mov	DWORD PTR _t$14[rsp], eax
	cmp	DWORD PTR tv304[rsp], 0
	je	SHORT $LN23@ParamsSetu
	mov	rax, QWORD PTR _p$34[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$34[rsp]
	inc	rax
	mov	QWORD PTR _p$34[rsp], rax
	jmp	SHORT $LN24@ParamsSetu
$LN23@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN27@ParamsSetu
$LN22@ParamsSetu:

; 115  :     PF_ADD_SLIDER("Random seed",
; 116  :         0,
; 117  :         16384,
; 118  :         0,
; 119  :         16384,
; 120  :         0,
; 121  :         10);

	mov	DWORD PTR priv_err$16[rsp], 0
	mov	DWORD PTR def$[rsp+12], 1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG118062
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR def$[rsp+rax+60], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR def$[rsp+rax+92], 0
	mov	DWORD PTR def$[rsp+124], 0
	mov	DWORD PTR def$[rsp+132], 0
	mov	DWORD PTR def$[rsp+128], 16384		; 00004000H
	mov	DWORD PTR def$[rsp+136], 16384		; 00004000H
	mov	DWORD PTR def$[rsp+140], 0
	mov	eax, DWORD PTR def$[rsp+140]
	mov	DWORD PTR def$[rsp+56], eax
	mov	DWORD PTR def$[rsp], 10
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$16[rsp], eax
	cmp	DWORD PTR priv_err$16[rsp], 0
	je	SHORT $LN19@ParamsSetu
	mov	eax, DWORD PTR priv_err$16[rsp]
	jmp	$LN109@ParamsSetu
$LN19@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN22@ParamsSetu
$LN18@ParamsSetu:

; 122  : 
; 123  :     // ------------------------
; 124  :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$18[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$35[rsp], rax
$LN15@ParamsSetu:
	mov	eax, DWORD PTR _t$18[rsp]
	mov	DWORD PTR tv327[rsp], eax
	mov	eax, DWORD PTR _t$18[rsp]
	dec	eax
	mov	DWORD PTR _t$18[rsp], eax
	cmp	DWORD PTR tv327[rsp], 0
	je	SHORT $LN14@ParamsSetu
	mov	rax, QWORD PTR _p$35[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$35[rsp]
	inc	rax
	mov	QWORD PTR _p$35[rsp], rax
	jmp	SHORT $LN15@ParamsSetu
$LN14@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN18@ParamsSetu
$LN13@ParamsSetu:

; 125  :     PF_ADD_POPUP("Border",
; 126  :         4,
; 127  :         2,
; 128  :         "None|Expand|Mirror|Tile",
; 129  :         11);

	mov	DWORD PTR priv_err$20[rsp], 0
	mov	DWORD PTR def$[rsp+12], 7
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG118077
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	mov	eax, 4
	mov	WORD PTR def$[rsp+60], ax
	mov	eax, 2
	mov	WORD PTR def$[rsp+62], ax
	mov	DWORD PTR def$[rsp+56], 2
	lea	rax, OFFSET FLAT:$SG118078
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp], 11
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$20[rsp], eax
	cmp	DWORD PTR priv_err$20[rsp], 0
	je	SHORT $LN10@ParamsSetu
	mov	eax, DWORD PTR priv_err$20[rsp]
	jmp	$LN109@ParamsSetu
$LN10@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN13@ParamsSetu
$LN9@ParamsSetu:

; 130  : 
; 131  :     // ------------------------
; 132  :     AEFX_CLR_STRUCT(def);

	mov	DWORD PTR _t$22[rsp], 176		; 000000b0H
	lea	rax, QWORD PTR def$[rsp]
	mov	QWORD PTR _p$36[rsp], rax
$LN6@ParamsSetu:
	mov	eax, DWORD PTR _t$22[rsp]
	mov	DWORD PTR tv346[rsp], eax
	mov	eax, DWORD PTR _t$22[rsp]
	dec	eax
	mov	DWORD PTR _t$22[rsp], eax
	cmp	DWORD PTR tv346[rsp], 0
	je	SHORT $LN5@ParamsSetu
	mov	rax, QWORD PTR _p$36[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR _p$36[rsp]
	inc	rax
	mov	QWORD PTR _p$36[rsp], rax
	jmp	SHORT $LN6@ParamsSetu
$LN5@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@ParamsSetu
$LN4@ParamsSetu:

; 133  :     PF_ADD_CHECKBOX("Merge",
; 134  :         "元画像と合成します。",
; 135  :         TRUE,
; 136  :         0,
; 137  :         12);

	mov	DWORD PTR priv_err$24[rsp], 0
	mov	DWORD PTR def$[rsp+12], 4
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rax, QWORD PTR [rax+176]
	lea	rdx, OFFSET FLAT:$SG118093
	lea	rcx, QWORD PTR def$[rsp+16]
	call	QWORD PTR [rax+336]
	lea	rax, OFFSET FLAT:$SG118094
	mov	QWORD PTR def$[rsp+64], rax
	mov	DWORD PTR def$[rsp+56], 1
	mov	BYTE PTR def$[rsp+60], 1
	mov	eax, DWORD PTR def$[rsp+48]
	mov	DWORD PTR def$[rsp+48], eax
	mov	DWORD PTR def$[rsp], 12
	lea	r8, QWORD PTR def$[rsp]
	mov	edx, -1
	mov	rax, QWORD PTR in_data$[rsp]
	mov	rcx, QWORD PTR [rax+184]
	mov	rax, QWORD PTR in_data$[rsp]
	call	QWORD PTR [rax+16]
	mov	DWORD PTR priv_err$24[rsp], eax
	cmp	DWORD PTR priv_err$24[rsp], 0
	je	SHORT $LN1@ParamsSetu
	mov	eax, DWORD PTR priv_err$24[rsp]
	jmp	SHORT $LN109@ParamsSetu
$LN1@ParamsSetu:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@ParamsSetu

; 138  : 
; 139  :     out_data->num_params = MOONFACE_NUM_PARAMS;

	mov	rax, QWORD PTR out_data$[rsp]
	mov	DWORD PTR [rax+48], 13

; 140  : 
; 141  :     return err;

	mov	eax, DWORD PTR err$[rsp]
$LN109@ParamsSetu:

; 142  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 536				; 00000218H
	ret	0
?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ENDP ; ParamsSetup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
in_data$ = 8
out_data$ = 16
params$ = 24
output$ = 32
?GlobalSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z PROC ; GlobalSetup

; 25   : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 26   :     out_data->my_version = PF_VERSION(MAJOR_VERSION,
; 27   :         MINOR_VERSION,
; 28   :         BUG_VERSION,
; 29   :         STAGE_VERSION,
; 30   :         BUILD_VERSION);

	mov	rax, QWORD PTR out_data$[rsp]
	mov	DWORD PTR [rax], 524289			; 00080001H

; 31   : 
; 32   :     out_data->out_flags = PF_OutFlag_DEEP_COLOR_AWARE |	// just 16bpc, not 32bpc
; 33   :         PF_OutFlag_I_EXPAND_BUFFER |
; 34   :         PF_OutFlag_I_HAVE_EXTERNAL_DEPENDENCIES;

	mov	rax, QWORD PTR out_data$[rsp]
	mov	DWORD PTR [rax+96], 50332160		; 03000200H

; 35   : 
; 36   :     out_data->out_flags2 = PF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS |
; 37   :         PF_OutFlag2_I_USE_3D_CAMERA |
; 38   :         PF_OutFlag2_I_USE_3D_LIGHTS;

	mov	rax, QWORD PTR out_data$[rsp]
	mov	DWORD PTR [rax+400], 7

; 39   : 
; 40   :     return PF_Err_NONE;

	xor	eax, eax

; 41   : }

	ret	0
?GlobalSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ENDP ; GlobalSetup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
$T1 = 48
tv78 = 56
tv82 = 64
tv73 = 72
$T2 = 80
suites$ = 96
in_data$ = 976
out_data$ = 984
params$ = 992
output$ = 1000
?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z PROC ; About

; 9    : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 968				; 000003c8H
	mov	QWORD PTR $T2[rsp], -2

; 10   :     AEGP_SuiteHandler suites(in_data->pica_basicP);

	mov	rax, QWORD PTR in_data$[rsp]
	mov	rdx, QWORD PTR [rax+384]
	lea	rcx, QWORD PTR suites$[rsp]
	call	??0AEGP_SuiteHandler@@QEAA@PEBUSPBasicSuite@@@Z ; AEGP_SuiteHandler::AEGP_SuiteHandler
	npad	1

; 11   : 
; 12   :     suites.ANSICallbacksSuite1()->sprintf(out_data->return_msg,
; 13   :         "%s v%d.%d\r%s",
; 14   :         STR(StrID_Name),
; 15   :         MAJOR_VERSION,
; 16   :         MINOR_VERSION,
; 17   :         STR(StrID_Description));

	mov	ecx, 2
	call	GetStringPtr
	mov	QWORD PTR tv73[rsp], rax
	mov	ecx, 1
	call	GetStringPtr
	mov	QWORD PTR tv78[rsp], rax
	mov	rcx, QWORD PTR out_data$[rsp]
	add	rcx, 100				; 00000064H
	mov	QWORD PTR tv82[rsp], rcx
	lea	rcx, QWORD PTR suites$[rsp]
	call	?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ ; AEGP_SuiteHandler::ANSICallbacksSuite1
	mov	rcx, QWORD PTR tv73[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 1
	mov	rcx, QWORD PTR tv78[rsp]
	mov	r8, rcx
	lea	rdx, OFFSET FLAT:$SG117886
	mov	rcx, QWORD PTR tv82[rsp]
	call	QWORD PTR [rax+120]

; 18   : 
; 19   :     ShellExecute(NULL, "open", "http://syuilo.com", NULL, NULL, SW_SHOW);

	mov	DWORD PTR [rsp+40], 5
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:$SG117887
	lea	rdx, OFFSET FLAT:$SG117888
	xor	ecx, ecx
	call	QWORD PTR __imp_ShellExecuteA

; 20   : 
; 21   :     return PF_Err_NONE;

	mov	DWORD PTR $T1[rsp], 0
	lea	rcx, QWORD PTR suites$[rsp]
	call	??1AEGP_SuiteHandler@@QEAA@XZ		; AEGP_SuiteHandler::~AEGP_SuiteHandler
	mov	eax, DWORD PTR $T1[rsp]

; 22   : }

	add	rsp, 968				; 000003c8H
	ret	0
?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ENDP ; About
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
$T1 = 48
tv78 = 56
tv82 = 64
tv73 = 72
$T2 = 80
suites$ = 96
in_data$ = 976
out_data$ = 984
params$ = 992
output$ = 1000
?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA PROC ; `About'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR suites$[rbp]
	call	??1AEGP_SuiteHandler@@QEAA@XZ		; AEGP_SuiteHandler::~AEGP_SuiteHandler
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z@4HA ENDP ; `About'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
a$ = 32
b$ = 36
?genrand_res53@@YANXZ PROC				; genrand_res53

; 176  : {

$LN3:
	sub	rsp, 56					; 00000038H

; 177  :     unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;

	call	?genrand_int32@@YAKXZ			; genrand_int32
	shr	eax, 5
	mov	DWORD PTR a$[rsp], eax
	call	?genrand_int32@@YAKXZ			; genrand_int32
	shr	eax, 6
	mov	DWORD PTR b$[rsp], eax

; 178  :     return(a*67108864.0 + b)*(1.0 / 9007199254740992.0);

	mov	eax, DWORD PTR a$[rsp]
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@4190000000000000
	mov	eax, DWORD PTR b$[rsp]
	cvtsi2sd xmm1, rax
	addsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3ca0000000000000

; 179  : }

	add	rsp, 56					; 00000038H
	ret	0
?genrand_res53@@YANXZ ENDP				; genrand_res53
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
?genrand_real3@@YANXZ PROC				; genrand_real3

; 169  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 170  :     return (((double)genrand_int32()) + 0.5)*(1.0 / 4294967296.0);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	mov	eax, eax
	cvtsi2sd xmm0, rax
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	mulsd	xmm0, QWORD PTR __real@3df0000000000000

; 171  :     /* divided by 2^32 */
; 172  : }

	add	rsp, 40					; 00000028H
	ret	0
?genrand_real3@@YANXZ ENDP				; genrand_real3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
?genrand_real2@@YANXZ PROC				; genrand_real2

; 162  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 163  :     return genrand_int32()*(1.0 / 4294967296.0);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@3df0000000000000

; 164  :     /* divided by 2^32 */
; 165  : }

	add	rsp, 40					; 00000028H
	ret	0
?genrand_real2@@YANXZ ENDP				; genrand_real2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
?genrand_real1@@YANXZ PROC				; genrand_real1

; 155  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 156  :     return genrand_int32()*(1.0 / 4294967295.0);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@3df0000000100000

; 157  :     /* divided by 2^32-1 */
; 158  : }

	add	rsp, 40					; 00000028H
	ret	0
?genrand_real1@@YANXZ ENDP				; genrand_real1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
?genrand_int31@@YAJXZ PROC				; genrand_int31

; 149  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 150  :     return (long)(genrand_int32() >> 1);

	call	?genrand_int32@@YAKXZ			; genrand_int32
	shr	eax, 1

; 151  : }

	add	rsp, 40					; 00000028H
	ret	0
?genrand_int31@@YAJXZ ENDP				; genrand_int31
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
y$ = 32
kk$1 = 36
?genrand_int32@@YAKXZ PROC				; genrand_int32

; 111  : {

$LN11:
	sub	rsp, 56					; 00000038H

; 112  :     unsigned long y;
; 113  :     static unsigned long mag01[2] = { 0x0UL, MATRIX_A };
; 114  :     /* mag01[x] = x * MATRIX_A  for x=0,1 */
; 115  : 
; 116  :     if (mti >= MT_N) { /* generate N words at one time */

	cmp	DWORD PTR mti, 624			; 00000270H
	jl	$LN8@genrand_in

; 117  :         int kk;
; 118  : 
; 119  :         if (mti == MT_N + 1)   /* if init_genrand() has not been called, */

	cmp	DWORD PTR mti, 625			; 00000271H
	jne	SHORT $LN7@genrand_in

; 120  :             init_genrand(5489UL); /* a default initial seed is used */

	mov	ecx, 5489				; 00001571H
	call	?init_genrand@@YAXK@Z			; init_genrand
$LN7@genrand_in:

; 121  : 
; 122  :         for (kk = 0; kk<MT_N - MT_M; kk++) {

	mov	DWORD PTR kk$1[rsp], 0
	jmp	SHORT $LN6@genrand_in
$LN5@genrand_in:
	mov	eax, DWORD PTR kk$1[rsp]
	inc	eax
	mov	DWORD PTR kk$1[rsp], eax
$LN6@genrand_in:
	cmp	DWORD PTR kk$1[rsp], 227		; 000000e3H
	jge	SHORT $LN4@genrand_in

; 123  :             y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);

	movsxd	rax, DWORD PTR kk$1[rsp]
	lea	rcx, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax*4]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR kk$1[rsp]
	inc	ecx
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:mt
	mov	ecx, DWORD PTR [rdx+rcx*4]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 124  :             mt[kk] = mt[kk + MT_M] ^ (y >> 1) ^ mag01[y & 0x1UL];

	mov	eax, DWORD PTR kk$1[rsp]
	add	eax, 397				; 0000018dH
	cdqe
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR y$[rsp]
	shr	edx, 1
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	eax, edx
	mov	ecx, DWORD PTR y$[rsp]
	and	ecx, 1
	mov	ecx, ecx
	lea	rdx, OFFSET FLAT:?mag01@?1??genrand_int32@@YAKXZ@4PAKA
	xor	eax, DWORD PTR [rdx+rcx*4]
	movsxd	rcx, DWORD PTR kk$1[rsp]
	lea	rdx, OFFSET FLAT:mt
	mov	DWORD PTR [rdx+rcx*4], eax

; 125  :         }

	jmp	$LN5@genrand_in
$LN4@genrand_in:

; 126  :         for (; kk<MT_N - 1; kk++) {

	jmp	SHORT $LN3@genrand_in
$LN2@genrand_in:
	mov	eax, DWORD PTR kk$1[rsp]
	inc	eax
	mov	DWORD PTR kk$1[rsp], eax
$LN3@genrand_in:
	cmp	DWORD PTR kk$1[rsp], 623		; 0000026fH
	jge	SHORT $LN1@genrand_in

; 127  :             y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);

	movsxd	rax, DWORD PTR kk$1[rsp]
	lea	rcx, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax*4]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR kk$1[rsp]
	inc	ecx
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:mt
	mov	ecx, DWORD PTR [rdx+rcx*4]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 128  :             mt[kk] = mt[kk + (MT_M - MT_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];

	mov	eax, DWORD PTR kk$1[rsp]
	sub	eax, 227				; 000000e3H
	cdqe
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR y$[rsp]
	shr	edx, 1
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	eax, edx
	mov	ecx, DWORD PTR y$[rsp]
	and	ecx, 1
	mov	ecx, ecx
	lea	rdx, OFFSET FLAT:?mag01@?1??genrand_int32@@YAKXZ@4PAKA
	xor	eax, DWORD PTR [rdx+rcx*4]
	movsxd	rcx, DWORD PTR kk$1[rsp]
	lea	rdx, OFFSET FLAT:mt
	mov	DWORD PTR [rdx+rcx*4], eax

; 129  :         }

	jmp	$LN2@genrand_in
$LN1@genrand_in:

; 130  :         y = (mt[MT_N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);

	mov	eax, 4
	imul	rax, rax, 623				; 0000026fH
	lea	rcx, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, -2147483648			; 80000000H
	mov	ecx, 4
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:mt
	mov	ecx, DWORD PTR [rdx+rcx]
	btr	ecx, 31
	or	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 131  :         mt[MT_N - 1] = mt[MT_M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];

	mov	eax, 4
	imul	rax, rax, 396				; 0000018cH
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR y$[rsp]
	shr	edx, 1
	mov	eax, DWORD PTR [rcx+rax]
	xor	eax, edx
	mov	ecx, DWORD PTR y$[rsp]
	and	ecx, 1
	mov	ecx, ecx
	lea	rdx, OFFSET FLAT:?mag01@?1??genrand_int32@@YAKXZ@4PAKA
	xor	eax, DWORD PTR [rdx+rcx*4]
	mov	ecx, 4
	imul	rcx, rcx, 623				; 0000026fH
	lea	rdx, OFFSET FLAT:mt
	mov	DWORD PTR [rdx+rcx], eax

; 132  : 
; 133  :         mti = 0;

	mov	DWORD PTR mti, 0
$LN8@genrand_in:

; 134  :     }
; 135  : 
; 136  :     y = mt[mti++];

	movsxd	rax, DWORD PTR mti
	lea	rcx, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR y$[rsp], eax
	mov	eax, DWORD PTR mti
	inc	eax
	mov	DWORD PTR mti, eax

; 137  : 
; 138  :     /* Tempering */
; 139  :     y ^= (y >> 11);

	mov	eax, DWORD PTR y$[rsp]
	shr	eax, 11
	mov	ecx, DWORD PTR y$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 140  :     y ^= (y << 7) & 0x9d2c5680UL;

	mov	eax, DWORD PTR y$[rsp]
	shl	eax, 7
	and	eax, -1658038656			; 9d2c5680H
	mov	ecx, DWORD PTR y$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 141  :     y ^= (y << 15) & 0xefc60000UL;

	mov	eax, DWORD PTR y$[rsp]
	shl	eax, 15
	and	eax, -272236544				; efc60000H
	mov	ecx, DWORD PTR y$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 142  :     y ^= (y >> 18);

	mov	eax, DWORD PTR y$[rsp]
	shr	eax, 18
	mov	ecx, DWORD PTR y$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 143  : 
; 144  :     return y;

	mov	eax, DWORD PTR y$[rsp]

; 145  : }

	add	rsp, 56					; 00000038H
	ret	0
?genrand_int32@@YAKXZ ENDP				; genrand_int32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
i$ = 32
k$ = 36
j$ = 40
tv66 = 44
init_key$ = 64
key_length$ = 72
?init_by_array@@YAXQEAKH@Z PROC				; init_by_array

; 85   : {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 86   :     int i, j, k;
; 87   :     init_genrand(19650218UL);

	mov	ecx, 19650218				; 012bd6aaH
	call	?init_genrand@@YAXK@Z			; init_genrand

; 88   :     i = 1; j = 0;

	mov	DWORD PTR i$[rsp], 1
	mov	DWORD PTR j$[rsp], 0

; 89   :     k = (MT_N>key_length ? MT_N : key_length);

	cmp	DWORD PTR key_length$[rsp], 624		; 00000270H
	jge	SHORT $LN12@init_by_ar
	mov	DWORD PTR tv66[rsp], 624		; 00000270H
	jmp	SHORT $LN13@init_by_ar
$LN12@init_by_ar:
	mov	eax, DWORD PTR key_length$[rsp]
	mov	DWORD PTR tv66[rsp], eax
$LN13@init_by_ar:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR k$[rsp], eax

; 90   :     for (; k; k--) {

	jmp	SHORT $LN9@init_by_ar
$LN8@init_by_ar:
	mov	eax, DWORD PTR k$[rsp]
	dec	eax
	mov	DWORD PTR k$[rsp], eax
$LN9@init_by_ar:
	cmp	DWORD PTR k$[rsp], 0
	je	$LN7@init_by_ar

; 91   :         mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1664525UL))
; 92   :             + init_key[j] + j; /* non linear */

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR i$[rsp]
	dec	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:mt
	mov	r9d, DWORD PTR i$[rsp]
	dec	r9d
	movsxd	r9, r9d
	lea	r10, OFFSET FLAT:mt
	mov	r9d, DWORD PTR [r10+r9*4]
	shr	r9d, 30
	mov	edx, DWORD PTR [r8+rdx*4]
	xor	edx, r9d
	imul	edx, edx, 1664525			; 0019660dH
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	eax, edx
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR init_key$[rsp]
	add	eax, DWORD PTR [rdx+rcx*4]
	add	eax, DWORD PTR j$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:mt
	mov	DWORD PTR [rdx+rcx*4], eax

; 93   :         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:mt
	movsxd	rdx, DWORD PTR i$[rsp]
	lea	r8, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [r8+rdx*4], eax

; 94   :         i++; j++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax

; 95   :         if (i >= MT_N) { mt[0] = mt[MT_N - 1]; i = 1; }

	cmp	DWORD PTR i$[rsp], 624			; 00000270H
	jl	SHORT $LN6@init_by_ar
	mov	eax, 4
	imul	rax, rax, 623				; 0000026fH
	lea	rcx, OFFSET FLAT:mt
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	r8, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR [r8+rdx], eax
	mov	DWORD PTR i$[rsp], 1
$LN6@init_by_ar:

; 96   :         if (j >= key_length) j = 0;

	mov	eax, DWORD PTR key_length$[rsp]
	cmp	DWORD PTR j$[rsp], eax
	jl	SHORT $LN5@init_by_ar
	mov	DWORD PTR j$[rsp], 0
$LN5@init_by_ar:

; 97   :     }

	jmp	$LN8@init_by_ar
$LN7@init_by_ar:

; 98   :     for (k = MT_N - 1; k; k--) {

	mov	DWORD PTR k$[rsp], 623			; 0000026fH
	jmp	SHORT $LN4@init_by_ar
$LN3@init_by_ar:
	mov	eax, DWORD PTR k$[rsp]
	dec	eax
	mov	DWORD PTR k$[rsp], eax
$LN4@init_by_ar:
	cmp	DWORD PTR k$[rsp], 0
	je	$LN2@init_by_ar

; 99   :         mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1566083941UL))
; 100  :             - i; /* non linear */

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR i$[rsp]
	dec	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:mt
	mov	r9d, DWORD PTR i$[rsp]
	dec	r9d
	movsxd	r9, r9d
	lea	r10, OFFSET FLAT:mt
	mov	r9d, DWORD PTR [r10+r9*4]
	shr	r9d, 30
	mov	edx, DWORD PTR [r8+rdx*4]
	xor	edx, r9d
	imul	edx, edx, 1566083941			; 5d588b65H
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	eax, edx
	sub	eax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:mt
	mov	DWORD PTR [rdx+rcx*4], eax

; 101  :         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:mt
	movsxd	rdx, DWORD PTR i$[rsp]
	lea	r8, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [r8+rdx*4], eax

; 102  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 103  :         if (i >= MT_N) { mt[0] = mt[MT_N - 1]; i = 1; }

	cmp	DWORD PTR i$[rsp], 624			; 00000270H
	jl	SHORT $LN1@init_by_ar
	mov	eax, 4
	imul	rax, rax, 623				; 0000026fH
	lea	rcx, OFFSET FLAT:mt
	mov	edx, 4
	imul	rdx, rdx, 0
	lea	r8, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR [r8+rdx], eax
	mov	DWORD PTR i$[rsp], 1
$LN1@init_by_ar:

; 104  :     }

	jmp	$LN3@init_by_ar
$LN2@init_by_ar:

; 105  : 
; 106  :     mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */

	mov	eax, 4
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:mt
	mov	DWORD PTR [rcx+rax], -2147483648	; 80000000H

; 107  : }

	add	rsp, 56					; 00000038H
	ret	0
?init_by_array@@YAXQEAKH@Z ENDP				; init_by_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\mt.h
_TEXT	SEGMENT
s$ = 8
?init_genrand@@YAXK@Z PROC				; init_genrand

; 66   : {

	mov	DWORD PTR [rsp+8], ecx

; 67   :     mt[0] = s & 0xffffffffUL;

	mov	eax, 4
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR s$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 68   :     for (mti = 1; mti<MT_N; mti++) {

	mov	DWORD PTR mti, 1
	jmp	SHORT $LN3@init_genra
$LN2@init_genra:
	mov	eax, DWORD PTR mti
	inc	eax
	mov	DWORD PTR mti, eax
$LN3@init_genra:
	cmp	DWORD PTR mti, 624			; 00000270H
	jge	SHORT $LN1@init_genra

; 69   :         mt[mti] =
; 70   :             (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);

	mov	eax, DWORD PTR mti
	dec	eax
	cdqe
	lea	rcx, OFFSET FLAT:mt
	mov	edx, DWORD PTR mti
	dec	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:mt
	mov	edx, DWORD PTR [r8+rdx*4]
	shr	edx, 30
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	eax, edx
	imul	eax, eax, 1812433253			; 6c078965H
	add	eax, DWORD PTR mti
	movsxd	rcx, DWORD PTR mti
	lea	rdx, OFFSET FLAT:mt
	mov	DWORD PTR [rdx+rcx*4], eax

; 71   :         /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
; 72   :         /* In the previous versions, MSBs of the seed affect   */
; 73   :         /* only MSBs of the array mt[].                        */
; 74   :         /* 2002/01/09 modified by Makoto Matsumoto             */
; 75   :         mt[mti] &= 0xffffffffUL;

	movsxd	rax, DWORD PTR mti
	lea	rcx, OFFSET FLAT:mt
	movsxd	rdx, DWORD PTR mti
	lea	r8, OFFSET FLAT:mt
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [r8+rdx*4], eax

; 76   :         /* for >32 bit machines */
; 77   :     }

	jmp	$LN2@init_genra
$LN1@init_genra:

; 78   : }

	ret	0
?init_genrand@@YAXK@Z ENDP				; init_genrand
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\template\moonface\moonface.cpp
_TEXT	SEGMENT
err$ = 32
tv64 = 36
tv90 = 40
tv91 = 44
tv92 = 48
tv93 = 52
$T1 = 56
thrown_err$2 = 64
cmd$ = 96
in_data$ = 104
out_data$ = 112
params$ = 120
output$ = 128
extra$ = 136
EntryPointFunc PROC

; 389  : {

$LN15:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR $T1[rsp], -2

; 390  :     PF_Err		err = PF_Err_NONE;

	mov	DWORD PTR err$[rsp], 0

; 391  : 
; 392  :     try {
; 393  :         switch (cmd) {

	mov	eax, DWORD PTR cmd$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 0
	je	SHORT $LN4@EntryPoint
	cmp	DWORD PTR tv64[rsp], 1
	je	SHORT $LN3@EntryPoint
	cmp	DWORD PTR tv64[rsp], 4
	je	SHORT $LN2@EntryPoint
	cmp	DWORD PTR tv64[rsp], 11
	je	$LN1@EntryPoint
	jmp	$LN5@EntryPoint
$LN4@EntryPoint:

; 394  :             case PF_Cmd_ABOUT:
; 395  :                 err = About(in_data, out_data, params, output);

	mov	r9, QWORD PTR output$[rsp]
	mov	r8, QWORD PTR params$[rsp]
	mov	rdx, QWORD PTR out_data$[rsp]
	mov	rcx, QWORD PTR in_data$[rsp]
	call	?About@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ; About
	mov	DWORD PTR tv90[rsp], eax
	mov	eax, DWORD PTR tv90[rsp]
	mov	DWORD PTR err$[rsp], eax

; 396  :                 break;

	jmp	SHORT $LN5@EntryPoint
$LN3@EntryPoint:

; 397  :             case PF_Cmd_GLOBAL_SETUP:
; 398  :                 err = GlobalSetup(in_data, out_data, params, output);

	mov	r9, QWORD PTR output$[rsp]
	mov	r8, QWORD PTR params$[rsp]
	mov	rdx, QWORD PTR out_data$[rsp]
	mov	rcx, QWORD PTR in_data$[rsp]
	call	?GlobalSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ; GlobalSetup
	mov	DWORD PTR tv91[rsp], eax
	mov	eax, DWORD PTR tv91[rsp]
	mov	DWORD PTR err$[rsp], eax

; 399  :                 break;

	jmp	SHORT $LN5@EntryPoint
$LN2@EntryPoint:

; 400  :             case PF_Cmd_PARAMS_SETUP:
; 401  :                 err = ParamsSetup(in_data, out_data, params, output);

	mov	r9, QWORD PTR output$[rsp]
	mov	r8, QWORD PTR params$[rsp]
	mov	rdx, QWORD PTR out_data$[rsp]
	mov	rcx, QWORD PTR in_data$[rsp]
	call	?ParamsSetup@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ; ParamsSetup
	mov	DWORD PTR tv92[rsp], eax
	mov	eax, DWORD PTR tv92[rsp]
	mov	DWORD PTR err$[rsp], eax

; 402  :                 break;

	jmp	SHORT $LN5@EntryPoint
$LN1@EntryPoint:

; 403  :             case PF_Cmd_RENDER:
; 404  :                 err = Render(in_data, out_data, params, output);

	mov	r9, QWORD PTR output$[rsp]
	mov	r8, QWORD PTR params$[rsp]
	mov	rdx, QWORD PTR out_data$[rsp]
	mov	rcx, QWORD PTR in_data$[rsp]
	call	?Render@@YAJPEAUPF_InData@@PEAUPF_OutData@@QEAPEAUPF_ParamDef@@PEAUPF_LayerDef@@@Z ; Render
	mov	DWORD PTR tv93[rsp], eax
	mov	eax, DWORD PTR tv93[rsp]
	mov	DWORD PTR err$[rsp], eax
$LN5@EntryPoint:
	jmp	SHORT $LN12@EntryPoint
$LN13@EntryPoint:
$LN12@EntryPoint:

; 405  :                 break;
; 406  :         }
; 407  :     } catch (PF_Err &thrown_err){
; 408  :         err = thrown_err;
; 409  :     }
; 410  :     return err;

	mov	eax, DWORD PTR err$[rsp]

; 411  : }

	add	rsp, 88					; 00000058H
	ret	0
EntryPointFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
err$ = 32
tv64 = 36
tv90 = 40
tv91 = 44
tv92 = 48
tv93 = 52
$T1 = 56
thrown_err$2 = 64
cmd$ = 96
in_data$ = 104
out_data$ = 112
params$ = 120
output$ = 128
extra$ = 136
EntryPointFunc$catch$0 PROC

; 407  :     } catch (PF_Err &thrown_err){

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$EntryPointFunc$0:

; 408  :         err = thrown_err;

	mov	rax, QWORD PTR thrown_err$2[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR err$[rbp], eax

; 409  :     }

	lea	rax, $LN13@EntryPoint
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
EntryPointFunc$catch$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\util\aegp_suitehandler.h
;	COMDAT ?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ
_TEXT	SEGMENT
this$ = 48
?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ PROC ; AEGP_SuiteHandler::ANSICallbacksSuite1, COMDAT

; 417  : 	AEGP_SUITE_ACCESS_BOILERPLATE(ANSICallbacksSuite, 1, PF_, ansi_callbacks_suite1P, kPFANSISuite, kPFANSISuiteVersion1);

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+312], 0
	jne	SHORT $LN1@ANSICallba
	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_0O@JPGHEGPP@PF?5ANSI?5Suite?$AA@
	mov	rcx, QWORD PTR this$[rsp]
	call	?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z ; AEGP_SuiteHandler::LoadSuite
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+312], rax
$LN1@ANSICallba:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+312]
	add	rsp, 40					; 00000028H
	ret	0
?ANSICallbacksSuite1@AEGP_SuiteHandler@@QEBAPEAUPF_ANSICallbacksSuite1@@XZ ENDP ; AEGP_SuiteHandler::ANSICallbacksSuite1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\syuilo\documents\visual studio 2013\projects\after_effects_cs5_sdk_win\adobe after effects cs5 win sdk\examples\util\aegp_suitehandler.h
;	COMDAT ?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z
_TEXT	SEGMENT
err$ = 32
suiteP$ = 40
this$ = 64
nameZ$ = 72
versionL$ = 80
?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z PROC	; AEGP_SuiteHandler::LoadSuite, COMDAT

; 218  : 	{

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 219  : 		const void *suiteP;
; 220  : 		A_long err = i_pica_basicP->AcquireSuite(nameZ, versionL, &suiteP);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	lea	r8, QWORD PTR suiteP$[rsp]
	mov	edx, DWORD PTR versionL$[rsp]
	mov	rcx, QWORD PTR nameZ$[rsp]
	call	QWORD PTR [rax]
	mov	DWORD PTR err$[rsp], eax

; 221  : 
; 222  : 		if (err || !suiteP) {

	cmp	DWORD PTR err$[rsp], 0
	jne	SHORT $LN1@LoadSuite
	cmp	QWORD PTR suiteP$[rsp], 0
	jne	SHORT $LN2@LoadSuite
$LN1@LoadSuite:

; 223  : 			MissingSuiteError();

	mov	rcx, QWORD PTR this$[rsp]
	call	?MissingSuiteError@AEGP_SuiteHandler@@AEBAXXZ ; AEGP_SuiteHandler::MissingSuiteError
$LN2@LoadSuite:

; 224  : 		}
; 225  : 
; 226  : 		return (void*)suiteP;

	mov	rax, QWORD PTR suiteP$[rsp]

; 227  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?LoadSuite@AEGP_SuiteHandler@@AEBAPEAXPEADJ@Z ENDP	; AEGP_SuiteHandler::LoadSuite
_TEXT	ENDS
END
